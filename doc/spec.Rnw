\documentclass[11pt]{article}
\usepackage[portrait, headheight=0.5cm, margin=2cm, top=2cm]{geometry}
\usepackage{graphicx}
\usepackage[dvipsnames,table]{xcolor}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{pdfpages}
\usepackage[export]{adjustbox}
\usepackage{booktabs}
\usepackage{tikz}
\usetikzlibrary{shadings,arrows.meta,positioning,calc,intersections}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=NavyBlue,
    urlcolor=NavyBlue,
    citecolor=NavyBlue
}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily\small,
  frame=single,
  columns=fullflexible,
  keepspaces=true,
  backgroundcolor=\color{gray!10},
  rulecolor=\color{gray!50},
  breaklines=true,
  showstringspaces=false
}
\usepackage{array}
\usepackage{enumitem}
\usepackage{fancyhdr}

% Header/Footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\small\textsf{specparser}}
\fancyhead[R]{\small\textsf{DSL Reference Manual}}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Custom colors
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}

% Sweave setup
<<setup, include=FALSE>>=
run_code <- FALSE
@


\title{
\vspace{2cm}
{\Huge\sffamily\bfseries specparser}\\[0.5cm]
{\Large\sffamily Domain-Specific Language for Parametric Expansion}\\[2cm]
\rule{\textwidth}{1pt}
}
\author{\textsf{Reference Manual}}
\date{\textsf{\today}}

\begin{document}
\maketitle
\thispagestyle{empty}

\newpage
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Introduction}

The \texttt{specparser} package implements a domain-specific language (DSL) for
generating parametric combinations and expanding specifications. It is designed
for creating variations of specifications with support for ranges, choices,
references, and image metadata embedding.

\subsection{Package Structure}

The package is organized into several modules with clear responsibilities:

\begin{center}
\begin{tabular}{ll}
\toprule
\textbf{Module} & \textbf{Purpose} \\
\midrule
\texttt{expander.py} & DSL core: scanner, parser, cartesian expansion \\
\texttt{expander\_state.py} & Shared state: DICT, NAMES, RNG \\
\texttt{init\_funcs.py} & Init-time functions (\verb|!{...}|) \\
\texttt{expand\_funcs.py} & Expand-time functions (\verb|${...}|) \\
\texttt{render\_funcs.py} & Render-time functions (\verb|#{...}|) \\
\texttt{chain.py} & Key:value chain parsing \\
\texttt{chain\_state.py} & Chain parser state: NAMES, FUNCS \\
\texttt{files.py} & File reading utilities \\
\texttt{dates.py} & Exchange calendar utilities \\
\texttt{slots.py} & Slot management for images \\
\texttt{image2spec.py} & Image metadata handling \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Execution Phases}

The DSL executes in three distinct phases:

\begin{enumerate}[itemsep=1ex]
  \item \textbf{Init Phase} (\verb|!{...}|) --- Runs once before expansion.
        Used to set seeds, define constants, load data into DICT.
  \item \textbf{Expand Phase} (\verb|${...}|, \verb|[...]|, \verb|{...}|, \verb|@{...}|) ---
        Computes the cartesian product of all dimensions.
  \item \textbf{Render Phase} (\verb|#{...}|) --- Evaluates per-row expressions
        after dimension values are selected.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Specification Expander (\texttt{expander.py})}

The \texttt{expander.py} module implements the core DSL engine. It transforms
spec strings into enumerated lists of fully-expanded parameter combinations.

\subsection{Core Concepts}

A spec string is composed of \emph{literals} and several structured constructs.
Left-to-right parsing identifies \emph{dimension units}. These units are expanded
independently, and their Cartesian product defines the final output.

\subsection{Syntax Overview}

\begin{center}
\begin{tabular}{llp{8cm}}
\toprule
\textbf{Pattern} & \textbf{Phase} & \textbf{Description} \\
\midrule
\verb|[a,b,c]| & Expand & Cartesian product dimension \\
\verb|>[a,b,c]| & Expand & Progressive (accumulating) list \\
\verb|{1:10}| & Expand & Numeric range (step mode) \\
\verb|{0:1_0.1}| & Expand & Range with explicit step \\
\texttt{\{0:1\textbar 5\}} & Expand & Linspace (N samples) \\
\verb|${expr}| & Expand & Expression evaluation \\
\verb|@{regex}| & Expand & Dict key selector \\
\verb|#{expr}| & Render & Per-row reference \\
\verb|!{expr}| & Init & One-time setup \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Lists}

Square brackets define a dimension. The cartesian product of all dimensions is computed.

\begin{lstlisting}[language=Python]
expand("[a,b][1,2]")
# -> ['a1', 'a2', 'b1', 'b2']

expand("prefix_[x,y]_[1,2,3]_suffix")
# -> ['prefix_x_1_suffix', 'prefix_x_2_suffix', 'prefix_x_3_suffix',
#     'prefix_y_1_suffix', 'prefix_y_2_suffix', 'prefix_y_3_suffix']
\end{lstlisting}

\subsubsection{Nested Lists}

Lists can be nested inside list items for union expansion:

\begin{lstlisting}[language=Python]
expand_list_choices("a[b,c]d,e")
# -> ['abd', 'acd', 'e']
\end{lstlisting}

\subsection{Progressive Lists}

Progressive lists accumulate items instead of selecting one:

\begin{lstlisting}[language=Python]
expand(">[a,b,c]")
# -> ['a', 'a,b', 'a,b,c']
\end{lstlisting}

\subsection{Numeric Ranges}

Curly braces define numeric ranges with several formats:

\subsubsection{Step Mode}

Default step is 1 (or -1 for descending):

\begin{lstlisting}[language=Python]
expand("{1:5}")      # -> ['1', '2', '3', '4', '5']
expand("{5:1}")      # -> ['5', '4', '3', '2', '1']
\end{lstlisting}

\subsubsection{Explicit Step}

Use underscore to specify step magnitude:

\begin{lstlisting}[language=Python]
expand("{0:10_2}")    # -> ['0', '2', '4', '6', '8', '10']
expand("{0:1_0.25}")  # -> ['0', '0.25', '0.5', '0.75', '1']
\end{lstlisting}

\subsubsection{Linspace Mode}

Use pipe to specify number of samples (inclusive):

\begin{lstlisting}[language=Python]
expand("{0:1|5}")     # -> ['0', '0.25', '0.5', '0.75', '1']
expand("{0:100|3}")   # -> ['0', '50', '100']
\end{lstlisting}

\subsubsection{Zero-Padding}

Leading zeros in endpoints enable padding:

\begin{lstlisting}[language=Python]
expand("{01:05}")     # -> ['01', '02', '03', '04', '05']
expand("{001:100}")   # -> ['001', '002', ..., '100']
\end{lstlisting}

\subsection{Expressions}

Dollar-brace expressions are evaluated at expansion time:

\begin{lstlisting}[language=Python]
expand("value_${2+3}")     # -> ['value_5']
expand("item_${[1,2,3]}")  # -> ['item_1', 'item_2', 'item_3']
expand("${range(1,4)}")    # -> ['1', '2', '3']
\end{lstlisting}

Expressions have access to:
\begin{itemize}
  \item Math operators: \verb|+|, \verb|-|, \verb|*|, \verb|/|, \verb|**|, \verb|//|, \verb|%|
  \item Constants: \verb|pi|
  \item All functions in the \verb|FUNCS| registry
\end{itemize}

\subsection{Dict Selectors}

At-brace selectors match keys in the global \verb|DICT| and return their values:

\begin{lstlisting}[language=Python]
from specparser.expander import DICT

DICT.clear()
DICT.update({"color_red": "#ff0000", "color_blue": "#0000ff"})

expand("@{color_.*}")
# -> ['#ff0000', '#0000ff']  (values where key matches regex)
\end{lstlisting}

The pattern uses Python regex with \verb|fullmatch| semantics.

\subsection{References}

Hash-brace references are evaluated at render time (once per output row):

\begin{lstlisting}[language=Python]
expand("[a,b]{1:2}::#{d1}-#{d2}-#{row}")
# -> ['a1::a-1-1', 'a2::a-2-2', 'b1::b-1-3', 'b2::b-2-4']

expand("[x,y] row=#{row} of #{nrows}")
# -> ['x row=1 of 2', 'y row=2 of 2']
\end{lstlisting}

\subsubsection{Available Variables}

\begin{center}
\begin{tabular}{lp{9cm}}
\toprule
\textbf{Name} & \textbf{Description} \\
\midrule
\verb|row| & Current row number (1-based) \\
\verb|nrows| & Total number of rows \\
\verb|d1|, \verb|d2|, ... & Selected dimension values for current row \\
\verb|dim1|, \verb|dim2|, ... & Full dimension series (indexable by row) \\
\verb|choices1|, \verb|choices2|, ... & Full choice lists \\
\verb|ndims| & Number of dimensions \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Initialization}

Exclamation-brace expressions run once before expansion:

\begin{lstlisting}[language=Python]
expand("!{seed(42)}[a,b,c]")          # Set deterministic seed
expand("!{const('myval', 100)}${myval}")  # Define constant -> ['100']
expand("!{load('words.txt')}@{.*}")   # Load file into DICT
\end{lstlisting}

\subsection{Macros}

Macros are simple text replacements defined in \texttt{data/macros.txt}:

\begin{lstlisting}
@OUTDIR=/path/to/output
@PREFIX=my_prefix
\end{lstlisting}

Used in specs:

\begin{lstlisting}[language=Python]
expand("@OUTDIR/@PREFIX_{1:3}.jpg")
# -> ['/path/to/output/my_prefix_1.jpg', ...]
\end{lstlisting}

Macro keys must match pattern \verb|@[A-Z0-9@]+|.

\subsection{Expansion Semantics}

\begin{itemize}[itemsep=1ex]
  \item All list-like units (ranges, lists, selectors, \verb|${...}| expressions)
        become independent dimensions.
  \item The final output is the full Cartesian product of all dimensions.
  \item References \verb|#{n}| are resolved \emph{after} a specific combination is selected.
  \item Invalid constructs are preserved literally; the system does not abort.
\end{itemize}

\subsection{CLI Features}

\begin{lstlisting}[language=bash]
# Run self-test
python -m specparser.expander --selftest

# Expand a spec
python -m specparser.expander "[a,b]{1:3}" --expand

# List choices from a list
python -m specparser.expander "[a,b,c]" --choices

# Progressive choices
python -m specparser.expander ">[a,b,c]" --pchoices
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Chain Parser (\texttt{chain.py})}

The \texttt{chain.py} module implements a minimal, CLI-safe parser for
pipeline specifications of the form \verb|op:arg1:arg2,op2:arg1,...|.
It is designed to be robust against shell quoting issues and supports
a restricted expression language including complex numbers.

\subsection{Chain Syntax}

A \emph{chain} is a comma-separated list of items, where each item has the form
\verb|name:arg1:arg2:...|. The parser supports nested expressions with internal
commas by splitting only at \emph{top level}.

\begin{lstlisting}[language=Python]
from specparser.chain import split_chain, concat_chain

# Parse chain format
d = split_chain("key1:value1,key2:value2")
# -> {'key1': ['value1'], 'key2': ['value2']}

# Rebuild chain string
s = concat_chain(d)
# -> 'key1:value1,key2:value2'
\end{lstlisting}

\subsection{Scalar Expression Language}

Each argument token is parsed into a Python \verb|complex| value. The expression
language supports:

\begin{itemize}[itemsep=0.5ex]
  \item \textbf{Safe evaluation} via \verb|SimpleEval| with whitelisted operators
  \item \textbf{Constants}: \verb|pi|, \verb|tau|, \verb|e|, \verb|inf|, \verb|nan|,
        \verb|j|, \verb|i|, \verb|zero|, \verb|one|
  \item \textbf{Functions}: \verb|sin|, \verb|cos|, \verb|tan|, \verb|sqrt|, \verb|log|,
        \verb|exp|, \verb|abs|, \verb|min|, \verb|max|, \verb|lerp|
  \item \textbf{Fractional exponents}: \verb|1e2.1| is interpreted as $10^{2.1}$
\end{itemize}

\subsection{Name Normalization}

Operation names are normalized:
\begin{itemize}
  \item Names starting with \verb|!| are skipped (comment mechanism)
  \item A single leading underscore is removed (variant marking)
  \item Names are converted to lowercase
\end{itemize}

\subsection{Python API}

\begin{center}
\begin{tabular}{p{5cm}p{9cm}}
\toprule
\textbf{Function} & \textbf{Description} \\
\midrule
\verb|split_chain(chain)| & Split chain into dict mapping names to raw arg lists \\
\verb|concat_chain(d)| & Rebuild chain string from dict \\
\verb|parse_chain(chain, MAXA)| & Parse to list of (name, args) tuples \\
\verb|parse_names_and_args(chain)| & Returns (names, A) where A is numpy array \\
\verb|parse_args_only(chain)| & Returns only the argument matrix \\
\verb|extract_used_names(chain)| & Extract set of operation names \\
\verb|set_const(name, value)| & Register a constant \\
\bottomrule
\end{tabular}
\end{center}

\subsection{CLI Features}

\begin{lstlisting}[language=bash]
# Parse a spec
python -m specparser.chain --spec "op:1:max(2,3),foo:sin(pi)"

# Add custom constant
python -m specparser.chain --spec "op:myconst" --const myconst=42

# Output formats: pretty, json, args
python -m specparser.chain --spec "op:1:2" --format json

# Run self-tests
python -m specparser.chain --selftest-verbose
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Function Reference}

Functions are available in three contexts, each with its own registry:

\begin{center}
\begin{tabular}{llll}
\toprule
\textbf{Context} & \textbf{Syntax} & \textbf{Registry} & \textbf{When Executed} \\
\midrule
Init & \verb|!{...}| & \verb|INIT_FUNCS| & Once, before expansion \\
Expand & \verb|${...}| & \verb|FUNCS| & During expansion (returns choices) \\
Render & \verb|#{...}| & \verb|REF_FUNCS| & Per row, during rendering \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Init Functions (\texttt{!{...}})}

\begin{center}
\begin{tabular}{llp{7cm}}
\toprule
\textbf{Function} & \textbf{Signature} & \textbf{Description} \\
\midrule
\verb|seed| & \verb|seed(n=None)| & Set RNG seed. \verb|None| or \verb|"auto"| reseeds from entropy \\
\verb|const| & \verb|const(name, value)| & Define a constant available in expressions \\
\verb|new| & \verb|new(**kwargs)| & Replace DICT with key=value pairs \\
\verb|add| & \verb|add(**kwargs)| & Add key=value pairs to DICT \\
\verb|load| & \verb|load(path, ...)| & Load file lines into DICT \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Expand Functions (\texttt{\${...}})}

\subsubsection{Random}

\begin{center}
\begin{tabular}{llp{7cm}}
\toprule
\textbf{Function} & \textbf{Signature} & \textbf{Description} \\
\midrule
\verb|rint| & \verb|rint(N)| & Random int from 1 to N \\
\verb|rfloat| & \verb|rfloat(a, b)| & Random float between a and b \\
\bottomrule
\end{tabular}
\end{center}

\subsubsection{Dictionary}

\begin{center}
\begin{tabular}{llp{7cm}}
\toprule
\textbf{Function} & \textbf{Signature} & \textbf{Description} \\
\midrule
\verb|key| & \verb|key(pattern)| & Keys from DICT matching regex \\
\verb|value| & \verb|value(pattern)| & Values from DICT where key matches regex \\
\bottomrule
\end{tabular}
\end{center}

\subsubsection{Sequences}

\begin{center}
\begin{tabular}{llp{7cm}}
\toprule
\textbf{Function} & \textbf{Signature} & \textbf{Description} \\
\midrule
\verb|range| & \verb|range(start, stop, step)| & Python range \\
\verb|seq| & \verb|seq(n)| & n values from 0.0 to 1.0 (linspace) \\
\bottomrule
\end{tabular}
\end{center}

\subsubsection{File Reading}

\begin{center}
\begin{tabular}{llp{7cm}}
\toprule
\textbf{Function} & \textbf{Signature} & \textbf{Description} \\
\midrule
\verb|txt| & \verb|txt(filename)| & All lines from file \\
\verb|lines| & \verb|lines(filename, count)| & count random lines from file \\
\verb|lines2| & \verb|lines2(filename, count, delim)| & count pairs of random lines, joined \\
\bottomrule
\end{tabular}
\end{center}

\subsubsection{Slot Management}

\begin{center}
\begin{tabular}{llp{7cm}}
\toprule
\textbf{Function} & \textbf{Signature} & \textbf{Description} \\
\midrule
\verb|slots| & \verb|slots(count)| & Get count free slot numbers \\
\verb|used_slots| & \verb|used_slots(schema)| & List used slot numbers \\
\verb|free_slots| & \verb|free_slots(schema, count)| & Get count free slots for schema \\
\verb|first| & \verb|first(schema)| & First free slot number \\
\bottomrule
\end{tabular}
\end{center}

\subsubsection{Dates}

\begin{center}
\begin{tabular}{llp{7cm}}
\toprule
\textbf{Function} & \textbf{Signature} & \textbf{Description} \\
\midrule
\verb|bizdays| & \verb|bizdays(month, calendar)| & Trading days in month (YYYY-MM) \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Render Functions (\texttt{\#{...}})}

\subsubsection{Random Selection}

\begin{center}
\begin{tabular}{llp{7cm}}
\toprule
\textbf{Function} & \textbf{Signature} & \textbf{Description} \\
\midrule
\verb|choose| & \verb|choose(*args)| & Random choice from arguments \\
\verb|rval| & \verb|rval()| & Random value from DICT \\
\verb|rint| & \verb|rint(N)| & Random int from 1 to N \\
\verb|rfloat| & \verb|rfloat(a, b)| & Random float between a and b \\
\verb|rfloat3| & \verb|rfloat3(a, b)| & Random float, 3 decimal places \\
\bottomrule
\end{tabular}
\end{center}

\subsubsection{Type Conversion \& Formatting}

\begin{center}
\begin{tabular}{llp{7cm}}
\toprule
\textbf{Function} & \textbf{Signature} & \textbf{Description} \\
\midrule
\verb|num| & \verb|num(x)| & Convert to float \\
\verb|i| & \verb|i(x)| & Convert to int \\
\verb|str| & \verb|str(x)| & Convert to string \\
\verb|zfill| & \verb|zfill(x, width)| & Zero-pad to width \\
\verb|fmt| & \verb|fmt(template, *args)| & String format \\
\bottomrule
\end{tabular}
\end{center}

\subsubsection{Indexing}

\begin{center}
\begin{tabular}{llp{7cm}}
\toprule
\textbf{Function} & \textbf{Signature} & \textbf{Description} \\
\midrule
\verb|at| & \verb|at(seq, idx)| & Element at index \\
\verb|wat| & \verb|wat(seq, idx)| & Element at index with wrap-around \\
\bottomrule
\end{tabular}
\end{center}

\subsubsection{File Access}

\begin{center}
\begin{tabular}{llp{7cm}}
\toprule
\textbf{Function} & \textbf{Signature} & \textbf{Description} \\
\midrule
\verb|line| & \verb|line(filename, lineno)| & Specific line (0-based) \\
\verb|rline| & \verb|rline(filename)| & Random line \\
\verb|rline2| & \verb|rline2(filename, delim)| & Two random lines joined \\
\verb|r2line| & \verb|r2line(file1, file2, delim)| & Random line from each file joined \\
\bottomrule
\end{tabular}
\end{center}

\subsubsection{Interpolation}

\begin{center}
\begin{tabular}{llp{7cm}}
\toprule
\textbf{Function} & \textbf{Signature} & \textbf{Description} \\
\midrule
\verb|lerp| & \verb|lerp(start, end)| & Linear interpolation based on row position \\
\verb|square| & \verb|square(start, end)| & Generate square coordinates interpolated \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Adding Custom Functions}

\begin{lstlisting}[language=Python]
from specparser.expand_funcs import FUNCS
from specparser.render_funcs import REF_FUNCS
from specparser.init_funcs import INIT_FUNCS

# Expand-time function (returns list)
FUNCS['mylist'] = lambda n: [f"item_{i}" for i in range(n)]

# Render-time function (returns scalar)
REF_FUNCS['upper'] = lambda s: s.upper()

# Init function
INIT_FUNCS['setup'] = lambda: print("Setting up...")
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Shared State (\texttt{expander\_state.py})}

The \texttt{expander\_state.py} module contains shared mutable state used
across all function modules.

\subsection{DICT}

The term dictionary used for \verb|@{...}| lookups:

\begin{lstlisting}[language=Python]
from specparser.expander_state import DICT, set_dict, clear_dict

DICT["mykey"] = "myvalue"
set_dict({"a": "1", "b": "2"})  # replace
clear_dict()                    # empty
\end{lstlisting}

\subsection{NAMES}

Constants available in expressions:

\begin{lstlisting}[language=Python]
from specparser.expander_state import NAMES, set_name, get_name

set_name("myconst", 42)
value = get_name("myconst")
\end{lstlisting}

\subsection{RNG}

Single source of randomness:

\begin{lstlisting}[language=Python]
from specparser.expander_state import RNG, seed, get_rng

seed(42)           # deterministic
seed()             # from OS entropy
rng = get_rng()    # access Random instance
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Utility Modules}

\subsection{Files (\texttt{files.py})}

File reading utilities with caching and random line selection:

\begin{lstlisting}[language=Python]
from specparser.files import (
    all_lines,       # All lines from file
    get_line,        # Specific line (0-based)
    get_lines,       # N random lines
    get_random_line, # One random line
    get_lines_paired,# N pairs of random lines
    set_seed,        # Set RNG seed
    clear_cache,     # Clear file cache
)
\end{lstlisting}

\textbf{CLI:}
\begin{lstlisting}[language=bash]
python -m specparser.files myfile.txt          # List all lines
python -m specparser.files myfile.txt -l 5     # Get line 5
python -m specparser.files myfile.txt -r 3     # 3 random lines
python -m specparser.files myfile.txt -c       # Count lines
\end{lstlisting}

\subsection{Dates (\texttt{dates.py})}

Exchange calendar utilities using the \texttt{exchange\_calendars} package:

\begin{lstlisting}[language=Python]
from specparser.dates import (
    good_days,         # Trading days in month
    holidays,          # All non-trading days
    weekday_holidays,  # Weekday-only holidays
    calendars,         # Available calendar codes
)

good_days("2024-01")         # NYSE trading days in Jan 2024
good_days("2024-01", "XLON") # London exchange
\end{lstlisting}

\textbf{CLI:}
\begin{lstlisting}[language=bash]
python -m specparser.dates 2024-01              # Trading days
python -m specparser.dates 2024-01 -o           # All non-trading days
python -m specparser.dates 2024-01 -w           # Weekday holidays only
python -m specparser.dates 2024-01 -c XLON      # London exchange
python -m specparser.dates -l                   # List all calendars
\end{lstlisting}

\subsection{Slots (\texttt{slots.py})}

Slot management for organizing generated images:

\begin{lstlisting}[language=Python]
from specparser.slots import (
    used_files,       # List files matching schema
    used_slots,       # List used slot numbers
    max_slot,         # Highest used slot
    first_free_slot,  # Next available slot
    free_slots,       # N free slots
    slots2jpegs,      # Convert slots to jpeg paths
    slots2specs,      # Convert slots to spec paths
)

# Schema is "directory/stem" - matches files like "directory/stem_00001.jpg"
used_slots("output/image")    # -> [1, 2, 5, 7]
first_free_slot("output/image")  # -> 3
free_slots("output/image", 4)    # -> [3, 4, 6, 8]
\end{lstlisting}

\subsection{Image Metadata (\texttt{image2spec.py})}

Read and write spec strings in JPEG EXIF metadata:

\begin{lstlisting}[language=Python]
from specparser.image2spec import (
    spec2image,         # Write spec to image metadata
    read_spec_exiftool, # Read spec from image metadata
)

spec2image("image.jpg", "key1:value1,key2:value2")
spec = read_spec_exiftool("image.jpg")
\end{lstlisting}

\textbf{Requires:} \texttt{exiftool} command-line tool

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Module Dependency Graph}

\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm,
    module/.style={
        rectangle,
        draw=NavyBlue,
        fill=NavyBlue!10,
        rounded corners,
        minimum width=3.5cm,
        minimum height=0.8cm,
        font=\small\ttfamily
    },
    util/.style={
        rectangle,
        draw=gray,
        fill=gray!10,
        rounded corners,
        minimum width=2.5cm,
        minimum height=0.6cm,
        font=\small\ttfamily
    },
    arrow/.style={
        ->,
        >=stealth,
        thick,
        gray
    }
]

% Core modules
\node[module] (state) {expander\_state.py};
\node[module, above=of state] (init) {init\_funcs.py};
\node[module, above=of init] (expand) {expand\_funcs.py};
\node[module, above=of expand] (render) {render\_funcs.py};
\node[module, above=of render] (expander) {expander.py};

% Utility modules
\node[util, right=3cm of state] (chain) {chain.py};
\node[util, above=0.8cm of chain] (files) {files.py};
\node[util, above=0.8cm of files] (dates) {dates.py};
\node[util, above=0.8cm of dates] (slots) {slots.py};
\node[util, above=0.8cm of slots] (image) {image2spec.py};

% Core arrows
\draw[arrow] (init) -- (state);
\draw[arrow] (expand) -- (state);
\draw[arrow] (render) -- (state);
\draw[arrow] (expander) -- (state);
\draw[arrow] (expander) -- (init);
\draw[arrow] (expander) -- (expand);
\draw[arrow] (expander) -- (render);

% Cross-module dependencies
\draw[arrow, bend right=20] (expand.east) to (chain.west);
\draw[arrow, bend right=15] (expand.east) to (files.west);
\draw[arrow, bend right=10] (expand.east) to (dates.west);
\draw[arrow, bend right=5] (expand.east) to (slots.west);
\draw[arrow] (expand.east) to (image.west);

\draw[arrow, bend left=15] (render.east) to (files.west);
\draw[arrow, bend left=10] (render.east) to (slots.west);

\end{tikzpicture}
\end{center}

Utility modules (\texttt{chain}, \texttt{files}, \texttt{dates}, \texttt{slots},
\texttt{image2spec}) have minimal dependencies and can be used standalone.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Quick Reference}

\subsection{Expansion Patterns}

\begin{center}
\begin{tabular}{lp{10cm}}
\toprule
\textbf{Pattern} & \textbf{Example} \\
\midrule
\verb|[a,b,c]| & \verb|[red,green,blue]| $\to$ red, green, blue \\
\verb|>[a,b,c]| & \verb|>[a,b,c]| $\to$ a, a,b, a,b,c \\
\verb|{a:b}| & \verb|{1:5}| $\to$ 1, 2, 3, 4, 5 \\
\verb|{a:b_step}| & \verb|{0:10_2}| $\to$ 0, 2, 4, 6, 8, 10 \\
\texttt{\{a:b\textbar N\}} & \texttt{\{0:1\textbar 5\}} $\to$ 0, 0.25, 0.5, 0.75, 1 \\
\verb|{01:05}| & \verb|{01:05}| $\to$ 01, 02, 03, 04, 05 \\
\verb|${expr}| & \verb|${2+3}| $\to$ 5 \\
\verb|@{regex}| & \verb|@{color_.*}| $\to$ values where key matches \\
\verb|#{expr}| & \verb|#{row}| $\to$ current row number \\
\verb|!{expr}| & \verb|!{seed(42)}| $\to$ set random seed \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Common Patterns}

\begin{lstlisting}[language=Python]
# Cartesian product
expand("[a,b][1,2]")           # -> ['a1', 'a2', 'b1', 'b2']

# Numbered sequence with references
expand("{1:3} item_#{d1}")     # -> ['1 item_1', '2 item_2', '3 item_3']

# Random per row
expand("[a,b,c] #{choose('x','y')}")

# Linear interpolation
expand("{1:5} #{lerp(0,100)}") # -> ['1 0', '2 25.0', ..., '5 100']

# Zero-padded files
expand("file_{001:100}.jpg")   # -> ['file_001.jpg', ..., 'file_100.jpg']

# Trading days
expand("${bizdays('2024-01')}")
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Self-Tests}

\subsection{Expander Self-Test}

<<expander-test, engine='bash', echo=TRUE, eval=run_code>>=
cd .. && uv run python -m specparser.expander --selftest
@

\subsection{Chain Parser Self-Test}

<<chain-test, engine='bash', echo=TRUE, eval=run_code>>=
cd .. && uv run python -m specparser.chain --selftest-verbose
@

\end{document}
